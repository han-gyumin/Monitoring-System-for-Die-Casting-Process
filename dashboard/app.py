# ================================
# üì¶ 1. Import
# ================================
from io import BytesIO
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages
from shiny import App, ui, render, reactive
import pandas as pd
import matplotlib.pyplot as plt
from shared import RealTimeStreamer, StreamAccumulator
from shared import sensor_labels, static_df, streaming_df, spec_df_all
import numpy as np
from datetime import datetime, timedelta
import matplotlib as mpl
import joblib
import warnings
from plotly.graph_objs import Figure, Scatter
import plotly.graph_objs as go
from shinywidgets import render_widget
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import os

warnings.filterwarnings('ignore')

mold_codes = ['ALL','8412', '8413', '8576', '8722', '8917']

plt.rcParams['font.family'] = 'Malgun Gothic'  # ÏúàÎèÑÏö∞
mpl.rcParams['axes.unicode_minus'] = False  # ÎßàÏù¥ÎÑàÏä§ Î∂ÄÌò∏ Íπ®Ïßê Î∞©ÏßÄ

selected_cols = [
    'molten_temp',           # Ïö©ÌÉï Ïò®ÎèÑ
    'cast_pressure',         # Ï£ºÏ°∞ ÏïïÎ†•
    'high_section_speed',    # Í≥†ÏÜç Íµ¨Í∞Ñ ÏÜçÎèÑ
    'low_section_speed',     # Ï†ÄÏÜç Íµ¨Í∞Ñ ÏÜçÎèÑ
    'biscuit_thickness'      # ÎπÑÏä§ÌÇ∑ ÎëêÍªò
]
df_selected = streaming_df[selected_cols].reset_index(drop=True)
STATIC_DIR = os.path.join(os.path.dirname(__file__), "www")

# ================================
# üñºÔ∏è 2. UI Ï†ïÏùò
# ================================

app_ui = ui.page_fluid(
            ui.output_ui("dynamic_ui")  # Ï†ÑÏ≤¥ UIÎäî ÏÑúÎ≤ÑÏóêÏÑú Ï°∞Í±¥Ïóê Îî∞Îùº Ï∂úÎ†•
        )

# ================================
# ‚öôÔ∏è 3. ÏÑúÎ≤Ñ Î°úÏßÅ
# ================================
def server(input, output, session):
    # Ï¥àÍ∏∞ ÏÉÅÌÉú
    streamer = reactive.Value(RealTimeStreamer())
    accumulator = reactive.value(StreamAccumulator(static_df))
    current_data = reactive.Value(pd.DataFrame())
    is_streaming = reactive.Value(False)


    prediction_table_logs = reactive.Value([])  # TAB 3. [B] Î°úÍ∑∏ ÌÖåÏù¥Î∏îÏö©
    anomaly_detail_logs = reactive.Value([])
    # Î°úÍ∑∏Ïù∏ ÏÉÅÌÉú Ï†ÄÏû•
    login_status = reactive.Value(False)
    
    alert_logs = reactive.Value([])  # Ïã§ÏãúÍ∞Ñ Í≤ΩÍ≥† ÎàÑÏ†Å

    # ================================
    # Ïä§Ìä∏Î¶¨Î∞ç Ï†úÏñ¥
    # ================================
    @reactive.effect
    @reactive.event(input.start)
    def on_start():
        is_streaming.set(True)

    @reactive.effect
    @reactive.event(input.pause)
    def on_pause():
        is_streaming.set(False)

    @reactive.effect
    @reactive.event(input.reset)
    def on_reset():
        streamer.get().reset_stream()
        current_data.set(pd.DataFrame())
        is_streaming.set(False)

    @reactive.effect
    def stream_data():
        try:
            if not is_streaming.get():
                return
            reactive.invalidate_later(1
                                      )
            s = streamer.get()
            next_batch = s.get_next_batch(1)
            if next_batch is not None:
                current_data.set(s.get_current_data())

                # ‚úÖ ÎàÑÏ†ÅÍ∏∞Î°ù ÌÅ¥ÎûòÏä§ÎèÑ ÏóÖÎç∞Ïù¥Ìä∏ (Ï†ÑÏ≤¥ Ïª¨Îüº)
                accum = accumulator.get()
                accum.accumulate(next_batch)  # ÎÇ¥Î∂Ä ÏÉÅÌÉú Í∞±Ïã†
            else:
                is_streaming.set(False)
        except Exception as e:
            print("‚õî Ïò§Î•ò Î∞úÏÉù:", e)
            is_streaming.set(False)


    # ================================
    # TAB 1: Ïã§ÏãúÍ∞Ñ Í≥µÏ†ï Î™®ÎãàÌÑ∞ÎßÅ   Process Monitoring
    # ================================

    # ‚ñ∂ Îç∞Ïù¥ÌÑ∞ Ïä§Ìä∏Î¶¨Î∞ç ÏßÑÌñâÎ•†ÏùÑ ÌçºÏÑºÌä∏Î°ú ÌëúÏãúÌï©ÎãàÎã§.
    @output
    @render.ui
    def stream_status():
        try:
            status = "üü¢ Ïä§Ìä∏Î¶¨Î∞ç Ï§ë" if is_streaming.get() else "üî¥ Ï†ïÏßÄÎê®"
            return status
        except Exception as e:
            return f"ÏóêÎü¨: {str(e)}"
        
        
    # ================================
    # TAP 1 [A] - Ïä§Ìä∏Î¶¨Î∞ç ÌëúÏãú
    # ================================
    for code in ["ALL"] + mold_codes:
            @output(id=f"stream_plot_{code}")
            @render.plot
            def _plot(code=code):  # ‚úÖ ÌÅ¥Î°úÏ†Ä Ï∫°Ï≤ò
                try:
                    df = current_data.get()
                    if df.empty:
                        raise ValueError("Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§. ÏûëÏóÖÏùÑ ÏãúÏûëÌï¥Ï£ºÏÑ∏Ïöî.")

                    df["registration_time"] = pd.to_datetime(df["registration_time"], errors="coerce")

                    # ‚úÖ mold_code ÌïÑÌÑ∞ÎßÅ (ALLÏù¥Î©¥ Ï†ÑÏ≤¥)
                    if code != "ALL":
                        df = df[df["mold_code"] == int(code)]

                    # ‚úÖ ÏµúÍ∑º 30Î∂Ñ + tail(30)
                    t_latest = df["registration_time"].max()
                    df = df[df["registration_time"] >= t_latest - pd.Timedelta(minutes=30)]
                    df = df.tail(30)

                    cols_to_plot = [col for col in selected_cols if col in df.columns][:3]
                    if not cols_to_plot:
                        raise ValueError("ÏãúÍ∞ÅÌôîÌï† ÏÑºÏÑú Ïª¨ÎüºÏù¥ ÏóÜÏäµÎãàÎã§.")

                    colors = ['#1f77b4', '#ff7f0e', '#2ca02c']
                    fig, axs = plt.subplots(nrows=len(cols_to_plot), figsize=(10, 3.5 * len(cols_to_plot)), sharex=True)
                    if len(cols_to_plot) == 1:
                        axs = [axs]

                    for i, col in enumerate(cols_to_plot):
                        ax = axs[i]
                        ax.plot(df["registration_time"], df[col],
                                label=col,
                                color=colors[i % len(colors)],
                                linewidth=2,
                                marker='o', markersize=5)

                        # ‚úÖ ÏÉÅÌïú/ÌïòÌïúÏÑ† ÌëúÏãú (Îã®, code != "ALL"Ïùº ÎïåÎßå)
                        if code != "ALL":
                            spec_row = spec_df_all[
                                (spec_df_all["mold_code"] == int(code)) & (spec_df_all["variable"] == col)
                            ]
                            if not spec_row.empty:
                                upper = spec_row["upper"].values[0]
                                lower = spec_row["lower"].values[0]
                                ax.axhline(y=upper, color="red", linestyle="--", linewidth=1.2, label="ÏÉÅÌïú")
                                ax.axhline(y=lower, color="blue", linestyle="--", linewidth=1.2, label="ÌïòÌïú")

                        ax.set_ylabel(col)
                        ax.legend(loc="upper right")  # ÎòêÎäî "lower left", "center", (x, y) ÌäúÌîåÎèÑ Í∞ÄÎä•
                        ax.grid(True)

                    axs[-1].set_xlabel("Ïõî-Ïùº Ïãú:Î∂Ñ")
                    axs[-1].xaxis.set_major_formatter(mdates.DateFormatter('%m-%d %H:%M'))
                    fig.autofmt_xdate()
                    fig.tight_layout()
                    return fig

                except Exception as e:
                    print(f"‚õî stream_plot_{code} Ïò§Î•ò:", e)
                    fig, ax = plt.subplots()
                    ax.text(0.5, 0.5, f"ÏóêÎü¨ Î∞úÏÉù: {str(e)}", ha="center", va="center", fontsize=12, color='red')
                    ax.axis("off")
                    return fig


    # ================================
    # TAP 1 [B] - Ïã§ÏãúÍ∞Ñ Í∞í 
    # ================================
    @output
    @render.ui
    def real_time_values():
        try:
            df = current_data.get()
            if df.empty:
                return ui.div("Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå", class_="text-muted")

            latest = df.iloc[-1] if len(df) > 0 else None
            prev = df.iloc[-2] if len(df) > 1 else latest

            # ‚úÖ Í∑∏ÎûòÌîÑ ÏÉâÏÉÅÍ≥º Îß§Ïπ≠
            sensor_colors = {
                'molten_temp': '#1f77b4',
                'cast_pressure': '#ff7f0e',
                'upper_mold_temp1': '#2ca02c'
                # Ï∂îÍ∞Ä ÏÑºÏÑú ÏÉâÏÉÅÎèÑ Ïó¨Í∏∞Ïóê
            }

            cards = []

            # ‚úÖ [Ï∂îÍ∞Ä] mold_code Ïπ¥Îìú ÏÇΩÏûÖ
            if 'mold_code' in df.columns:
                mold_code_val = latest['mold_code']
                cards.append(
                    ui.div(
                        ui.h6("Mold Code"),
                        ui.h4(str(mold_code_val), class_="fw-bold"),
                        class_="card p-3 mb-2 border border-info"
                    )
                )
            
            for col in sensor_labels:
                if col in df.columns:
                    current_val = latest[col]
                    prev_val = prev[col] if prev is not None else current_val
                    diff = current_val - prev_val
                    percent_change = (diff / prev_val * 100) if prev_val != 0 else 0

                    # Ï¶ùÍ∞ê ÌôîÏÇ¥Ìëú Î∞è ÏÉâÏÉÅ
                    if diff > 0:
                        arrow = "‚¨ÜÔ∏è"
                        color_class = "text-muted"
                    elif diff < 0:
                        arrow = "‚¨áÔ∏è"
                        color_class = "text-muted"
                    else:
                        arrow = "‚û°Ô∏è"
                        color_class = "text-muted"

                    # ================================
                    # Í≤ΩÍ≥† ÌÖåÎëêÎ¶¨ Ï†ÅÏö© (Ïä§Ìéô Î≤îÏúÑ Î≤óÏñ¥ÎÇ¨ÏùÑ Îïå)
                    # ================================
                    warning_class = ""
                    try:
                        mold_code_val = int(latest['mold_code'])  # mold_codeÍ∞Ä Î¨∏ÏûêÏó¥Ïùº Í≤ΩÏö∞ int Î≥ÄÌôò ÏãúÎèÑ
                        spec_row = spec_df_all[
                            (spec_df_all["mold_code"] == mold_code_val) &
                            (spec_df_all["variable"] == col)
                        ]
                        if not spec_row.empty:
                            lower_bound = spec_row["lower"].values[0]
                            upper_bound = spec_row["upper"].values[0]

                            if current_val < lower_bound or current_val > upper_bound:
                                warning_class = "border border-danger"
                    except Exception as e:
                        print(f"[Í≤ΩÍ≥† ÌÖåÎëêÎ¶¨ ÌåêÎã® Ïò§Î•ò] {col}: {e}")
                        # Ïò§Î•ò Î∞úÏÉù Ïãú Í≤ΩÍ≥† ÎØ∏Ï†ÅÏö©ÌïòÍ≥† ÌÜµÍ≥º

                    # ÏÉâÏÉÅ Ï†ÅÏö©
                    custom_color = sensor_colors.get(col, "#000000")

                    cards.append(
                        ui.div(
                            ui.h6(col.replace('_', ' ').title()),
                            ui.h4(
                                f"{current_val:.1f} {arrow} ({diff:+.1f}, {percent_change:+.1f}%)",
                                class_=color_class,
                                style=f"color: {custom_color}; font-weight: bold;"
                            ),
                            class_=f"card p-3 mb-2 {warning_class}"
                    
                        )
                    )

            return ui.div(*cards, class_="d-flex flex-column gap-2")

        except Exception as e:
            return ui.div(f"Ïò§Î•ò: {str(e)}", class_="text-danger")

    # ================================
    # TAP 1 [C] - Ïã§ÏãúÍ∞Ñ Î°úÍ∑∏
    # ================================
    @output
    @render.ui
    def recent_data_table():
        try:
            df = current_data.get()
            if df.empty:
                return ui.HTML("<p class='text-muted'>Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå</p>")

            df = df.tail(7).round(2).copy()
            rows = []

            # Ìó§Îçî Ìñâ
            header_cells = [ui.tags.th(col) for col in df.columns]
            rows.append(ui.tags.tr(*header_cells))

            # Îç∞Ïù¥ÌÑ∞ Ìñâ
            for i, row in df.iterrows():
                is_latest = i == df.index[-1]
                style = "background-color: #fff7d1;" if is_latest else ""
                cells = [ui.tags.td(str(val)) for val in row]
                rows.append(ui.tags.tr(*cells, style=style))

            return ui.tags.table(
                {"class": "table table-sm table-striped table-bordered", "style": "font-size: 13px;"},
                *rows
            )

        except Exception as e:
            return ui.HTML(f"<p class='text-danger'>ÏóêÎü¨ Î∞úÏÉù: {str(e)}</p>")
    

    # ================================
    # TAP 1 [C] - Ïã§ÏãúÍ∞Ñ ÏÑ†ÌÉù Îã§Ïö¥Î°úÎìú 
    # ================================
    @output
    @render.ui
    def download_controls():
        return ui.div(
            ui.input_select("file_format", "Îã§Ïö¥Î°úÎìú ÌòïÏãù", {
                "csv": "CSV",
                "xlsx": "Excel",
                "pdf": "PDF"
            }, selected="csv"),
            ui.download_button("download_recent_data", "üì• ÏµúÍ∑º Î°úÍ∑∏ Îã§Ïö¥Î°úÎìú")
        )
    # ================================
    # TAP 1 [C] - Ïã§ÏãúÍ∞Ñ ÏÑ†ÌÉù Îã§Ïö¥Î°úÎìú Î°úÏßÅ  
    # ================================
    @output
    @render.download(filename=lambda: f"recent_log.{input.file_format()}")
    def download_recent_data():
        def writer():
            df = current_data.get().tail(1000).round(2)
            file_format = input.file_format()

            if df.empty:
                return

            if file_format == "csv":
                yield df.to_csv(index=False).encode("utf-8")

            elif file_format == "xlsx":
                buffer = BytesIO()
                with pd.ExcelWriter(buffer, engine="xlsxwriter") as writer:
                    df.to_excel(writer, sheet_name="RecentLog", index=False)
                yield buffer.getvalue()

            elif file_format == "pdf":
                buffer = BytesIO()
                with PdfPages(buffer) as pdf:
                    fig, ax = plt.subplots(figsize=(8.5, 4))
                    ax.axis("off")
                    table = ax.table(cellText=df.values, colLabels=df.columns, loc="center")
                    table.auto_set_font_size(False)
                    table.set_fontsize(10)
                    table.scale(1.2, 1.2)
                    pdf.savefig(fig, bbox_inches='tight')
                    plt.close(fig)
                yield buffer.getvalue()
        return writer()
    # ================================
    # TAP 1 [D] - Ïù¥ÏÉÅ Î∂àÎüâ ÏïåÎ¶º 
    # ================================
    @output
    @render.ui
    def anomaly_alerts():
        try:
            df = current_data.get()
            if df.empty:
                return ui.div("Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå", class_="text-muted")

            # ÏµúÏã† Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
            latest = df.iloc[-1]

            # Ïù¥ÏÉÅ Ïó¨Î∂Ä ÌåêÎã® (-1: Ïù¥ÏÉÅ / 1: Ï†ïÏÉÅ)
            try:
                anomaly_val_raw = latest.get('is_anomaly', 1)
                anomaly_val = int(float(anomaly_val_raw))
            except:
                anomaly_val = 1  # ÌååÏã± Ïã§Ìå® Ïãú Ï†ïÏÉÅ

            anomaly_status = "Ïù¥ÏÉÅ" if anomaly_val == -1 else "Ï†ïÏÉÅ"
            anomaly_icon = "‚ùå" if anomaly_val == -1 else "‚úÖ"
            color_class = "alert alert-danger" if anomaly_val == -1 else "alert alert-success"
            anomaly_score = latest.get('anomaly_level', 0)
            # ÏãúÍ∞Å Ï†ïÎ¶¨
            reg_time = latest.get('registration_time')
            try:
                reg_time = pd.to_datetime(reg_time).strftime("%Y-%m-%d %H:%M:%S")
            except:
                reg_time = str(reg_time)
            icon = "‚úÖ" if anomaly_score == "Ï†ïÏÉÅ" else "‚ùå"
            return ui.div(
                ui.div(
                    ui.h6(f"üßæ Ïù¥ÏÉÅ ÌÉêÏßÄ"),
                    ui.h4(f"{icon} {anomaly_score}", class_="fw-bold"),
                    ui.h6("üïí ÌåêÏ†ï ÏãúÍ∞Ñ"),
                    ui.p(reg_time),
                    ui.input_action_button("goto_2page", "Ïù¥ÏÉÅÌÉêÏßÄ ÌôïÏù∏ÌïòÍ∏∞", class_="btn btn-sm btn-outline-primary"),
                    class_=f"{color_class} p-3 rounded"
                )
            )

        except Exception as e:
            return ui.div(f"Ïò§Î•ò: {str(e)}", class_="text-danger")
        
        
    @output
    @render.ui
    def current_prediction2():
        try:
            df = current_data.get()
            if df.empty:
                return ui.div("Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå", class_="text-muted")

            # ÏµúÏã† Îç∞Ïù¥ÌÑ∞ Ìïú Ìñâ
            latest = df.iloc[-1]

            if 'passorfail' not in latest:
                print("‚ö†Ô∏è 'passorfail' Ïª¨ÎüºÏù¥ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏùå")
                return ui.div("ÏòàÏ∏°Í∞í ÏóÜÏùå", class_="text-muted")

            # Í≤∞Ìï© ÌôïÎ•†ÏùÄ Ïù¥ÎØ∏ 'passorfail' Ïª¨ÎüºÏóê ÏòàÏ∏°Í∞íÏù¥ 0~1Î°ú Îì§Ïñ¥Ïò®Îã§Í≥† Í∞ÄÏ†ï
            prob = latest['passorfail']
            result = "Î∂àÎüâ" if prob >= 0.5 else "ÏñëÌíà"
            icon = "‚ùå" if result == "Î∂àÎüâ" else "‚úÖ"
            color_class = "alert alert-danger" if result == "Î∂àÎüâ" else "alert alert-success"

            reg_time = latest.get('registration_time')
            try:
                reg_time = pd.to_datetime(reg_time).strftime("%Y-%m-%d %H:%M:%S")
            except Exception as time_err:
                print(f"‚ö†Ô∏è ÏãúÍ∞Ñ ÌååÏã± Ïò§Î•ò: {time_err}")
                reg_time = "ÏãúÍ∞Ñ Ï†ïÎ≥¥ ÏóÜÏùå"

            return ui.div(
                ui.div(
                    ui.h6("üßæ ÌåêÏ†ï Í≤∞Í≥º"),
                    ui.h4(f"{icon} {result}", class_="fw-bold"),
                    class_="mb-2"
                ),
                ui.div(
                    ui.h6("üïí ÌåêÏ†ï ÏãúÍ∞Ñ"),
                    ui.p(reg_time),
                    ui.input_action_button("goto_3page", "Î∂àÎüâÌÉêÏßÄ ÌôïÏù∏ÌïòÍ∏∞", class_="btn btn-sm btn-outline-primary")
                ),
                class_=f"{color_class} p-3 rounded"
            )

        except Exception as e:
            print(f"‚õî current_prediction Ïò§Î•ò Î∞úÏÉù: {e}")
            return ui.div(f"Ïò§Î•ò: {str(e)}", class_="text-danger")
    @reactive.effect
    @reactive.event(input.goto_2page)
    def go_to_page_3():
        ui.update_navs("main_nav", "Í≥µÏ†ï Ïù¥ÏÉÅ ÌÉêÏßÄ   (Process Anomaly Detection)") 
    
    @reactive.effect
    @reactive.event(input.goto_3page)
    def go_to_page_3():
        ui.update_navs("main_nav", "ÌíàÏßà Ïù¥ÏÉÅ ÌåêÎ≥Ñ   (Quality Defect Classification)") 


    # ================================
    # TAB 2: [A] Ïù¥ÏÉÅ ÏòàÏ∏°
    # ================================
    @output
    @render.plot
    def anomaly_variable_count():
        try:
            df = accumulator.get().get_data()
            if df.empty:
                fig, ax = plt.subplots()
                ax.text(0.5, 0.5, "Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå", ha='center', va='center')
                return fig

            # Ïù¥ÏÉÅ Îç∞Ïù¥ÌÑ∞Îßå ÌïÑÌÑ∞ÎßÅ
            if 'is_anomaly' in df.columns:
                anomaly_df = df[df['is_anomaly'] == 1]
            else:
                # ÏûÑÏãúÎ°ú ÏÉÅÏúÑ 20% Îç∞Ïù¥ÌÑ∞Î•º Ïù¥ÏÉÅÏúºÎ°ú Í∞ÑÏ£º
                threshold = df['anomaly_score'].quantile(0.8) if 'anomaly_score' in df.columns else 0.8
                anomaly_df = df[df.get('anomaly_score', 0) > threshold]

            if anomaly_df.empty:
                fig, ax = plt.subplots()
                ax.text(0.5, 0.5, "Ïù¥ÏÉÅ Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå", ha='center', va='center')
                return fig

            # SHAP Í∏∞Ï§Ä Î≥ÄÏàòÎ≥Ñ ÏòÅÌñ•ÎèÑ ÏßëÍ≥Ñ (ÏãúÎÆ¨Î†àÏù¥ÏÖò)
            variables = sensor_labels
            counts = {}
            
            for var in variables:
                # Í∞Å Ïù¥ÏÉÅ ÏÉòÌîåÏóêÏÑú Ìï¥Îãπ Î≥ÄÏàòÍ∞Ä Í∞ÄÏû• ÌÅ∞ ÏòÅÌñ•ÏùÑ Ï§Ä ÌöüÏàò Í≥ÑÏÇ∞
                # Ïã§Ï†úÎ°úÎäî SHAP Í∞íÏùÑ ÏÇ¨Ïö©ÌïòÏßÄÎßå, Ïó¨Í∏∞ÏÑúÎäî ÏãúÎÆ¨Î†àÏù¥ÏÖò
                counts[var] = np.random.randint(1, len(anomaly_df)//2)

            fig, ax = plt.subplots(figsize=(10, 6))
            bars = ax.bar(counts.keys(), counts.values(), color=['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7'])
            ax.set_title("Ï£ºÏöî Î≥ÄÏàòÏùò Ïù¥ÏÉÅ Î∞úÏÉù ÌöüÏàò (SHAP Í∏∞Î∞ò)")
            ax.set_xlabel("Î≥ÄÏàòÎ™Ö")
            ax.set_ylabel("Ïù¥ÏÉÅ Î∞úÏÉù ÌöüÏàò")
            
            # ÎßâÎåÄ ÏúÑÏóê Í∞í ÌëúÏãú
            for bar in bars:
                height = bar.get_height()
                ax.text(bar.get_x() + bar.get_width()/2., height + 0.1,
                       f'{int(height)}', ha='center', va='bottom')
            
            plt.xticks(rotation=45)
            plt.tight_layout()
            fig.subplots_adjust(top=0.85, bottom=0.3)  # ÏúÑÏ™Ω 15%, ÏïÑÎûòÏ™Ω 30% Í≥µÍ∞Ñ ÌôïÎ≥¥
            return fig
            
        except Exception as e:
            fig, ax = plt.subplots()
            ax.text(0.5, 0.5, f"Ïò§Î•ò: {str(e)}", ha='center', va='center')
            return fig

    # ================================
    # TAB 2 [B]: 
    # ================================
    @reactive.effect
    @reactive.event(current_data)
    def update_alert_log():
        df = current_data.get()
        if df.empty:
            return

        latest = df.iloc[-1]
        level = latest.get("anomaly_level", "Ï†ïÏÉÅ")

        if level not in ["Í≤ΩÎèÑ", "Ïã¨Í∞Å"]:
            return  # Ï†ïÏÉÅÏùÄ Î¨¥Ïãú

        logs = alert_logs.get() or []
        logs.append({
            "time": pd.to_datetime(latest["registration_time"]).strftime("%Y-%m-%d %H:%M:%S"),
            "level": level
        })

        alert_logs.set(logs[-10:])

    @reactive.effect
    @reactive.event(input.clear_alerts)
    def clear_alert_logs():
        alert_logs.set([])  # ÎòêÎäî ÏÉÅÌÉú Î≥ÄÏàò Ï¥àÍ∏∞Ìôî
    
    @output
    @render.ui
    def log_alert_for_defect():
        logs = alert_logs.get() or []  # logsÍ∞Ä NoneÏùº Í≤ΩÏö∞Î•º ÎåÄÎπÑ
    
        # levelÎ≥Ñ ÌïÑÌÑ∞ÎßÅ (ÏóÜÏñ¥ÎèÑ 0ÏúºÎ°ú Î∞òÌôòÎêòÎèÑÎ°ù)
        mild_logs = [log for log in logs if log.get("level") == "Í≤ΩÎèÑ"]
        severe_logs = [log for log in logs if log.get("level") == "Ïã¨Í∞Å"]
        count_badge = ui.div(
            ui.HTML(f"<span style='margin-right:10px;'>üü† <b>Í≤ΩÎèÑ</b>: {len(mild_logs)}</span> | "
                    f"<span style='margin-left:10px;'>üî¥ <b>Ïã¨Í∞Å</b>: {len(severe_logs)}</span>"),
            class_="fw-bold mb-2"
        )
    
        if not logs:
            return ui.div(
                count_badge,
                ui.div("‚ö†Ô∏è Í≤ΩÎèÑ/Ïã¨Í∞Å Ïù¥ÏÉÅ Î°úÍ∑∏ ÏóÜÏùå", class_="text-muted"),
                class_="log-container"
            )
    
        entries = [
            ui.div(
                f"üïí {log['time']} - [{log['level']}] Ïù¥ÏÉÅ ÌÉêÏßÄÎê®",
                class_="text-danger" if log["level"] == "Ïã¨Í∞Å" else "text-warning"
            )
            for log in reversed(logs)
        ]
        
        return ui.div(count_badge, *entries, class_="log-container")
    # ================================
    # TAB 2 [C]: 
    # ================================
    @output
    @render.plot
    def anomaly_p_chart():
        try:
            df = accumulator.get().get_data()

            # ‚úÖ ÌïÑÏàò Ïª¨Îüº Ï°¥Ïû¨ Ïó¨Î∂Ä ÌôïÏù∏
            if df.empty:
                raise ValueError("Îç∞Ïù¥ÌÑ∞Í∞Ä ÎπÑÏñ¥ ÏûàÏäµÎãàÎã§.")
            if 'registration_time' not in df.columns:
                raise ValueError("registration_time Ïª¨ÎüºÏù¥ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§.")
            if 'is_anomaly' not in df.columns:
                raise ValueError("is_anomaly Ïª¨ÎüºÏù¥ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§.")

            # ‚úÖ datetime ÌååÏã±
            df['datetime'] = pd.to_datetime(df['registration_time'], errors='coerce')

            # ‚úÖ ÏãúÍ∞Ñ Îã®ÏúÑ ÏÑ†ÌÉù (input ID: anomaly_chart_time_unit)
            unit = input.anomaly_chart_time_unit()
            if unit == "1ÏãúÍ∞Ñ":
                df['time_group'] = df['datetime'].dt.floor('H')
            elif unit == "3ÏãúÍ∞Ñ":
                df['time_group'] = df['datetime'].dt.floor('3H')
            elif unit == "Ïùº":
                df['time_group'] = df['datetime'].dt.date
            elif unit == "Ï£º":
                df['time_group'] = df['datetime'].dt.to_period('W')
            elif unit == "Ïõî":
                df['time_group'] = df['datetime'].dt.to_period('M')
            else:
                raise ValueError(f"ÏÑ†ÌÉùÎêú ÏãúÍ∞Ñ Îã®ÏúÑ '{unit}'Î•º Ï≤òÎ¶¨Ìï† Ïàò ÏóÜÏäµÎãàÎã§.")

            # ‚úÖ Í∑∏Î£πÎ≥Ñ Ï¥ù Í±¥ÏàòÏôÄ Ïù¥ÏÉÅ Í±¥Ïàò Í≥ÑÏÇ∞
            n_i = df.groupby('time_group').size()
            x_i = df[df['is_anomaly'] == -1].groupby('time_group').size()
            x_i = x_i.reindex(n_i.index, fill_value=0)

            # ‚úÖ Î∂àÎüâÎ•† Î∞è Ï§ëÏã¨ÏÑ† Í≥ÑÏÇ∞
            p_i = x_i / n_i
            p_hat = x_i.sum() / n_i.sum()

            # ‚úÖ Í¥ÄÎ¶¨ ÌïúÍ≥ÑÏÑ† Í≥ÑÏÇ∞
            std_err = np.sqrt(p_hat * (1 - p_hat) / n_i)
            ucl = p_hat + 3 * std_err
            lcl = (p_hat - 3 * std_err).clip(lower=0)

            # ‚úÖ ÏµúÍ∑º 20Í∞úÎßå ÏãúÍ∞ÅÌôî
            last_n = 20
            df_plot = pd.DataFrame({
                "Group": n_i.index.astype(str),
                "DefectiveRate": p_i,
                "UCL": ucl,
                "LCL": lcl,
                "Center": p_hat
            }).sort_index().iloc[-last_n:].reset_index(drop=True)

            # ‚úÖ ÏãúÍ∞ÅÌôî
            fig, ax = plt.subplots(figsize=(12, 6))
            ax.plot(df_plot.index, df_plot["DefectiveRate"], marker="o", label="Defective Rate")
            ax.plot(df_plot.index, df_plot["UCL"], linestyle='--', color='red', label="UCL")
            ax.plot(df_plot.index, df_plot["LCL"], linestyle='--', color='red', label="LCL")
            ax.plot(df_plot.index, df_plot["Center"], linestyle=':', color='black', label="Center Line")
            ax.fill_between(df_plot.index, df_plot["LCL"], df_plot["UCL"], color='red', alpha=0.1)

            # ‚úÖ xÏ∂ï ÏÑ§Ï†ï
            ax.set_xticks(df_plot.index)
            ax.set_xticklabels(df_plot["Group"], rotation=45, ha='right')
            ax.set_ylabel("Í≥µÏ†ï Ïù¥ÏÉÅÎ•†")
            ax.set_title(f"Í≥µÏ†ï Ïù¥ÏÉÅÎ•† Í¥ÄÎ¶¨ÎèÑ (Îã®ÏúÑ: {unit})")
            ax.grid(True, alpha=0.3)
            ax.legend(loc="upper right")
            fig.tight_layout(pad=2.5)
            return fig

        except Exception as e:
            fig, ax = plt.subplots()
            ax.text(0.5, 0.5, f"Ïò§Î•ò Î∞úÏÉù: {str(e)}", ha='center', va='center', color='red')
            return fig
        
    # ================================
    # TAB 2 - [D] 
    # ================================
    @reactive.effect
    @reactive.event(current_data)
    def update_anomaly_details():
        df = current_data.get()
        if df.empty:
            return

        latest = df.iloc[-1]
        level = latest.get("anomaly_level", "Ï†ïÏÉÅ")

        if level not in ["Í≤ΩÎèÑ", "Ïã¨Í∞Å"]:
            return

        logs = anomaly_detail_logs.get() or []

        # Ï†ÑÏ≤¥ Ïª¨Îüº Í∞í Ï†ÄÏû• (dictÎ°ú Î≥ÄÌôò)
        row_data = latest.to_dict()
        row_data["level"] = level
        row_data["time"] = pd.to_datetime(latest["registration_time"]).strftime("%Y-%m-%d %H:%M:%S")

        logs.append(row_data)
        anomaly_detail_logs.set(logs)
        
    
    @output
    @render.ui
    def anomaly_detail_table():
        logs = anomaly_detail_logs.get()
        if not logs:
            return ui.div("‚ö†Ô∏è Ïù¥ÏÉÅÏπò ÏÉÅÏÑ∏ Î°úÍ∑∏ ÏóÜÏùå", class_="text-muted")

        rows = []

        for i, row in enumerate(reversed(logs), 1):
            details = [
                f"<b>{k}</b>: {v}" for k, v in row.items()
                if k not in ["level", "time"]
            ]
            level_color = "üî¥" if row["level"] == "Ïã¨Í∞Å" else "üü†"
            rows.append(
                ui.div(
                    ui.HTML(
                        f"{level_color} <b>{row['level']}</b> | üïí {row['time']}<br>"
                        + "<br>".join(details)
                    ),
                    class_="border rounded p-2 mb-2",
                    style="background-color: #fffdf5;" if row["level"] == "Í≤ΩÎèÑ" else "background-color: #fff5f5;"
                )
            )

        return ui.div(*rows, class_="log-container", style="max-height: 600px; overflow-y: auto;")

    @reactive.effect
    @reactive.event(input.clear_alerts2)
    def clear_alert_logs():
        #alert_logs.set([])               # Í∏∞Ï°¥ Í≤ΩÍ≥†/Ïã¨Í∞Å Î°úÍ∑∏ Ï¥àÍ∏∞Ìôî
        anomaly_detail_logs.set([])      # ‚úÖ SHAP ÏÉÅÏÑ∏ Î°úÍ∑∏ÎèÑ Ìï®Íªò Ï¥àÍ∏∞Ìôî

    # ================================
    # TAB 3 - [A] : ÌíàÏßà Î∂ÑÏÑù
    # ================================
    @output
    @render.plot
    def defect_rate_plot():
        try:
            unit = input.grouping_unit()  # "Ïùº", "Ï£º", "Ïõî"

            #df_vis = static_df.copy()
            df_vis = accumulator.get().get_data()

            # Î¨∏ÏûêÏó¥ ÎÇ†ÏßúÎ•º datetimeÏúºÎ°ú Î≥ÄÌôò
            df_vis['datetime'] = pd.to_datetime(df_vis['registration_time'], errors="coerce")

            # Í∑∏Î£πÌïë Í∏∞Ï§Ä Ï∂îÍ∞Ä
            if unit == "Ïùº":
                df_vis['group'] = df_vis['datetime'].dt.strftime('%Y-%m-%d')
            elif unit == "Ï£º":
                df_vis['group'] = df_vis['datetime'].dt.to_period('W').astype(str)
            elif unit == "Ïõî":
                df_vis['group'] = df_vis['datetime'].dt.to_period('M').astype(str)

            # Í∞Å Í∑∏Î£πÎ≥Ñ Î∂àÎüâÎ•† Í≥ÑÏÇ∞
            group_result = df_vis.groupby(['group', 'passorfail']).size().unstack(fill_value=0)
    
            selected_group = input.selected_group()
            if selected_group not in group_result.index:
                raise ValueError("ÏÑ†ÌÉùÌïú Í∑∏Î£πÏóê ÎåÄÌïú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.")
            counts = group_result.loc[selected_group]
    
            # ÏãúÍ∞ÅÌôî
            fig, ax = plt.subplots()
            labels = ['ÏñëÌíà', 'Î∂àÎüâ']
            sizes = [counts.get(0, 0), counts.get(1, 0)]
            colors = ['#4CAF50', '#F44336']
    
            wedges, _, _ = ax.pie(
                sizes, labels=labels, autopct='%1.1f%%', colors=colors, startangle=90
            )
            ax.axis('equal')
            ax.set_title(f"{selected_group} ({unit} Í∏∞Ï§Ä) Î∂àÎüâÎ•†")
            ax.legend(wedges, labels, title="ÏòàÏ∏° Í≤∞Í≥º", loc="upper right", bbox_to_anchor=(1.1, 1))
    
            return fig
    
        except Exception as e:
            fig, ax = plt.subplots()
            ax.text(0.5, 0.5, f"ÏóêÎü¨: {str(e)}", ha='center', va='center')
            return fig
        
    @output
    @render.ui
    def group_choice():
        try:
            unit = input.grouping_unit()
            df_vis = accumulator.get().get_data()
            df_vis['datetime'] = pd.to_datetime(df_vis['registration_time'], errors="coerce")

            if unit == "Ïùº":
                df_vis['group'] = df_vis['datetime'].dt.strftime('%Y-%m-%d')
            elif unit == "Ï£º":
                df_vis['group'] = df_vis['datetime'].dt.to_period('W').astype(str)
            elif unit == "Ïõî":
                df_vis['group'] = df_vis['datetime'].dt.to_period('M').astype(str)

            unique_groups = sorted(df_vis['group'].dropna().unique())
            return ui.input_select("selected_group", "üìÜ Ï°∞ÌöåÌï† Í∏∞Í∞Ñ ÏÑ†ÌÉù", choices=unique_groups, selected=unique_groups[-1] if unique_groups else None)
        except:
            return ui.input_select("selected_group", "üìÜ Ï°∞ÌöåÌï† Í∏∞Í∞Ñ ÏÑ†ÌÉù", choices=["ÏÑ†ÌÉù Î∂àÍ∞Ä"], selected=None)

    @output
    @render.plot
    def defect_rate_plot():
        try:
            # Í∏∞Í∞Ñ ÏÑ†ÌÉù
            start_date, end_date = input.date_range()

            df_vis = accumulator.get().get_data()
            df_vis = df_vis.loc[:, ~df_vis.columns.duplicated()]  # Ï§ëÎ≥µ Ïó¥ Ï†úÍ±∞
            df_vis['datetime'] = pd.to_datetime(df_vis['registration_time'], errors="coerce")

            # ÎÇ†Ïßú ÌïÑÌÑ∞ÎßÅ
            mask = (df_vis['datetime'].dt.date >= pd.to_datetime(start_date).date()) & \
                (df_vis['datetime'].dt.date <= pd.to_datetime(end_date).date())
            df_filtered = df_vis.loc[mask]

            if df_filtered.empty:
                raise ValueError("ÏÑ†ÌÉùÌïú Í∏∞Í∞Ñ ÎÇ¥ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.")

            # ‚úÖ Î™∞ÎìúÏΩîÎìú + Î∂àÎüâ Ïó¨Î∂ÄÎ≥Ñ Ïπ¥Ïö¥Ìä∏
            grouped = df_filtered.groupby(['mold_code', 'passorfail']).size().unstack(fill_value=0)
            grouped.columns = ['ÏñëÌíà', 'Î∂àÎüâ'] if 0 in grouped.columns else ['Î∂àÎüâ']
            grouped = grouped.reset_index()

            # ‚úÖ ÏãúÍ∞ÅÌôî (stacked bar chart)
            import numpy as np
            mold_codes = grouped['mold_code']
            x = np.arange(len(mold_codes))
            width = 0.6

            fig, ax = plt.subplots(figsize=(10, 5))
            ax.bar(x, grouped.get('ÏñëÌíà', [0]*len(grouped)), width, label='ÏñëÌíà', color='#4CAF50')
            ax.bar(x, grouped.get('Î∂àÎüâ', [0]*len(grouped)), width,
                bottom=grouped.get('ÏñëÌíà', [0]*len(grouped)), label='Î∂àÎüâ', color='#F44336')

            ax.set_xlabel('Î™∞Îìú ÏΩîÎìú')
            ax.set_ylabel('Í∞úÏàò')
            ax.set_title(f"{start_date} ~ {end_date} Î™∞ÎìúÏΩîÎìúÎ≥Ñ ÎàÑÏ†Å ÏòàÏ∏° Í≤∞Í≥º")
            ax.set_xticks(x)
            ax.set_xticklabels(mold_codes, rotation=45, ha='right')
            ax.legend()

            fig.tight_layout()
            return fig

        except Exception as e:
            print(f"[defect_rate_plot] ÏóêÎü¨: {e}")
            fig, ax = plt.subplots()
            ax.text(0.5, 0.5, f"ÏóêÎü¨ Î∞úÏÉù: {str(e)}", ha='center', va='center')
            return fig


    # ================================
    # TAP 3 [B]
    # ================================
    @output
    @render.ui
    def current_prediction():
        try:
            df = current_data.get()
            if df.empty:
                print("‚ö†Ô∏è current_dataÍ∞Ä ÎπÑÏñ¥ ÏûàÏùå")
                return ui.div("Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå", class_="text-muted")

            # ÏµúÏã† Îç∞Ïù¥ÌÑ∞ Ìïú Ìñâ
            latest = df.iloc[-1]

            if 'passorfail' not in latest:
                print("‚ö†Ô∏è 'passorfail' Ïª¨ÎüºÏù¥ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏùå")
                return ui.div("ÏòàÏ∏°Í∞í ÏóÜÏùå", class_="text-muted")

            # Í≤∞Ìï© ÌôïÎ•†ÏùÄ Ïù¥ÎØ∏ 'passorfail' Ïª¨ÎüºÏóê ÏòàÏ∏°Í∞íÏù¥ 0~1Î°ú Îì§Ïñ¥Ïò®Îã§Í≥† Í∞ÄÏ†ï
            prob = latest['passorfail']
            result = "Î∂àÎüâ" if prob >= 0.5 else "ÏñëÌíà"
            icon = "‚ùå" if result == "Î∂àÎüâ" else "‚úÖ"
            color_class = "alert alert-danger" if result == "Î∂àÎüâ" else "alert alert-success"

            reg_time = latest.get('registration_time')
            try:
                reg_time = pd.to_datetime(reg_time).strftime("%Y-%m-%d %H:%M:%S")
            except Exception as time_err:
                print(f"‚ö†Ô∏è ÏãúÍ∞Ñ ÌååÏã± Ïò§Î•ò: {time_err}")
                reg_time = "ÏãúÍ∞Ñ Ï†ïÎ≥¥ ÏóÜÏùå"

            return ui.div(
                ui.div(
                    ui.h6("üßæ ÌåêÏ†ï Í≤∞Í≥º"),
                    ui.h4(f"{icon} {result}", class_="fw-bold"),
                    class_="mb-2"
                ),
                ui.div(
                    ui.h6("üïí ÌåêÏ†ï ÏãúÍ∞Ñ"),
                    ui.p(reg_time)
                ),
                class_=f"{color_class} p-3 rounded"
            )

        except Exception as e:
            print(f"‚õî current_prediction Ïò§Î•ò Î∞úÏÉù: {e}")
            return ui.div(f"Ïò§Î•ò: {str(e)}", class_="text-danger")

    @reactive.effect
    @reactive.event(current_data)
    def log_prediction_from_current_row():
        df = current_data.get()
        if df.empty or 'passorfail' not in df.columns:
            return

        row = df.iloc[-1]
        prob = row.get('passorfail', None)

        if pd.isna(prob):
            return

        result = "Î∂àÎüâ" if prob >= 0.5 else "ÏñëÌíà"
        reg_time = row.get('registration_time')
        try:
            reg_time = pd.to_datetime(reg_time).strftime("%Y-%m-%d %H:%M:%S")
        except:
            reg_time = str(reg_time)

        logs = prediction_table_logs.get()
        logs.append({
            "ÌåêÏ†ï ÏãúÍ∞Ñ": reg_time,
            "Í≤∞Í≥º": result
        })
        prediction_table_logs.set(logs[-20:])  # ÏµúÏã† 20Í∞úÎßå Ïú†ÏßÄ

    @output
    @render.ui
    def prediction_log_table():
        logs = prediction_table_logs.get()
        if not logs:
            return ui.div("ÏòàÏ∏° Î°úÍ∑∏ ÏóÜÏùå", class_="text-muted")

        headers = ["ÌåêÏ†ï ÏãúÍ∞Ñ", "Í≤∞Í≥º"]
        table_rows = [ui.tags.tr(*[ui.tags.th(h) for h in headers])]

        for log in reversed(logs):  # ÏµúÏã†Ïù¥ ÏúÑÏóê
            table_rows.append(
                ui.tags.tr(
                    ui.tags.td(log["ÌåêÏ†ï ÏãúÍ∞Ñ"]),
                    ui.tags.td(log["Í≤∞Í≥º"]),
                )
            )

        return ui.div(
        ui.tags.table(
            {"class": "table table-sm table-bordered table-striped mb-0"},
            *table_rows
        ),
        style="max-height: 200px; overflow-y: auto;"  # Ïä§ÌÅ¨Î°§ ÏÑ§Ï†ï
    )
# ================================
    # TAP 3 [C] - Ïù¥ÏÉÅ Î∂àÎüâ ÏïåÎ¶º 
# ================================ 
    @output
    @render.plot
    def fail_rate_by_time():
        try:
            df = accumulator.get().get_data()
            if df.empty or 'passorfail' not in df.columns:
                raise ValueError("Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå")

            # datetime ÏÉùÏÑ±
            if 'datetime' not in df.columns:
                df['datetime'] = pd.to_datetime(df['registration_time'], errors='coerce')

            # ÏãúÍ∞Ñ Îã®ÏúÑ ÏÑ†ÌÉù
            unit = input.fail_time_unit()
            if unit == "1ÏãúÍ∞Ñ":
                df['time_group'] = df['datetime'].dt.floor('H')
            elif unit == "3ÏãúÍ∞Ñ":
                df['time_group'] = df['datetime'].dt.floor('3H')
            elif unit == "Ïùº":
                df['time_group'] = df['datetime'].dt.date
            elif unit == "Ï£º":
                df['time_group'] = df['datetime'].dt.to_period('W')
            elif unit == "Ïõî":
                df['time_group'] = df['datetime'].dt.to_period('M')

            # Î∂àÎüâÎ•† Í≥ÑÏÇ∞
            total_counts = df.groupby('time_group').size()
            fail_counts = df[df['passorfail'] == 1].groupby('time_group').size()
            rate = (fail_counts / total_counts).fillna(0)

            # ‚õî Í∏∞Ï°¥ ÏΩîÎìúÏóêÏÑúÎäî Ï†ÑÏ≤¥ rate ÏÇ¨Ïö©
            # ‚úÖ ÏàòÏ†ï: Í∞ÄÏû• ÏµúÍ∑º 20Í∞úÎßå ÏÇ¨Ïö©
            rate = rate.sort_index().iloc[-20:]  # ÏµúÍ∑º ÏãúÍ∞Ñ Í∏∞Ï§Ä Ï†ïÎ†¨ ÌõÑ 20Í∞ú ÏÑ†ÌÉù

            labels = rate.index.astype(str)
            values = rate.values

            fig, ax = plt.subplots(figsize=(12, 6))
            ax.plot(labels, values, marker='o', linestyle='-')
            ax.set_title(f"ÏãúÍ∞Ñ Îã®ÏúÑÎ≥Ñ Î∂àÎüâÎ•† Î∂ÑÏÑù ({unit}) - ÏµúÍ∑º 20Í∞ú")
            ax.set_xlabel("ÏãúÍ∞Ñ Îã®ÏúÑ")
            ax.set_ylabel("Î∂àÎüâÎ•†")
            ax.set_ylim(0, 1)
            ax.grid(True, alpha=0.3)
            plt.xticks(rotation=45)
            plt.tight_layout()
            return fig

        except Exception as e:
            fig, ax = plt.subplots()
            ax.text(0.5, 0.5, f"ÏóêÎü¨ Î∞úÏÉù: {str(e)}", ha='center', va='center')
            return fig

# ================================
# TAP 3 [D]
# ================================


# ================================
    # TAP 0  - Î°úÍ∑∏Ïù∏ Í∏∞Îä•
# ================================ 
    # Î°úÍ∑∏Ïù∏ Î≤ÑÌäº Ï≤òÎ¶¨
    @reactive.effect
    @reactive.event(input.login_button)
    def login():
        if input.username() == "admin" and input.password() == "1234":
            login_status.set(True)
        else:
            ui.notification_show("‚ùå Î°úÍ∑∏Ïù∏ Ïã§Ìå®", duration=3)

    # Î°úÍ∑∏ÏïÑÏõÉ Î≤ÑÌäº Ï≤òÎ¶¨
    @reactive.effect
    @reactive.event(input.logout_button)
    def logout():
        login_status.set(False)

    # Ï†ÑÏ≤¥ UI Î†åÎçîÎßÅ
    @output
    @render.ui
    def dynamic_ui():
        if not login_status.get():
            # Î°úÍ∑∏Ïù∏ ÌôîÎ©¥ Î∞òÌôò
            return ui.card(
                ui.div(
                    ui.tags.img(
                        src="./logo2.png",
                        style="max-width: 300px; margin-bottom: 20px;"
                    ),
                    class_="text-center"
                ),
                ui.card_header("LS Í∏∞Í∞Ä Ìå©ÌÜ†Î¶¨ Î°úÍ∑∏Ïù∏"),
                ui.input_text("username", "ÏïÑÏù¥Îîî"),
                ui.input_password("password", "ÎπÑÎ∞ÄÎ≤àÌò∏"),
                ui.input_action_button("login_button", "Î°úÍ∑∏Ïù∏"),
                ui.p("ID: admin / PW: 1234", class_="text-muted")
            )
        else:
            return ui.page_fluid(
                        ui.tags.head(
                            ui.tags.link(rel="stylesheet", href="./style.css")
                        ),
                        
                        ui.page_navbar(
                            # ================================
                            # TAB 1: Ïã§ÏãúÍ∞Ñ Í≥µÏ†ï Î™®ÎãàÌÑ∞ÎßÅ   Process Monitoring
                            # ================================
                            ui.nav_panel("Ïã§ÏãúÍ∞Ñ Í≥µÏ†ï Î™®ÎãàÌÑ∞ÎßÅ   (Process Monitoring)",
                                ui.layout_columns(
                                    # [A] Ïã§ÏãúÍ∞Ñ Í∑∏ÎûòÌîÑ
                                    ui.card(
                                        ui.row(
                                            ui.column(12,
                                                ui.div(
                                                    ui.input_action_button("start", "‚ñ∂ ÏãúÏûë", class_="btn-success me-2"),
                                                    ui.input_action_button("pause", "‚è∏ ÏùºÏãúÏ†ïÏßÄ", class_="btn-warning me-2"),
                                                    ui.input_action_button("reset", "üîÑ Î¶¨ÏÖã", class_="btn-secondary me-2"),
                                                    ui.output_ui("stream_status"),
                                                )
                                            )
                                        ),
                                        ui.card_header("[A] Ïã§ÏãúÍ∞Ñ ÏÑºÏÑú Ïä§Ìä∏Î¶¨Î∞ç"),
                                        ui.navset_tab(
                                            *[
                                                ui.nav_panel(
                                                    f"Î™∞ÎìúÏΩîÎìú {code}",
                                                    ui.output_plot(f"stream_plot_{code}", height="400px")
                                                )
                                                for code in mold_codes
                                            ]
                                        )
                                    ),
                                    # [B] Ïã§ÏãúÍ∞Ñ Í∞í
                                    ui.card(
                                        ui.card_header("[B] Ïã§ÏãúÍ∞Ñ Í∞í"),
                                        ui.output_ui("real_time_values"),
                                    ),
                                    col_widths=[8, 4]
                                ),
                                ui.layout_columns(
                                    # [C] Ïã§ÏãúÍ∞Ñ Î°úÍ∑∏
                                    ui.card(
                                        ui.card_header("[C] Ïã§ÏãúÍ∞Ñ Î°úÍ∑∏"),
                                        ui.div(
                                            ui.h5("Ïã§ÏãúÍ∞Ñ Î°úÍ∑∏ (ÏµúÍ∑º 10Í±¥)"),
                                            ui.output_table("recent_data_table"),
                                            ui.output_ui("download_controls")  # ÌòïÏãù ÏÑ†ÌÉù + Îã§Ïö¥Î°úÎìú Î≤ÑÌäº
                                        )
                                    ),
                                    # [D] Ïù¥ÏÉÅ Î∂àÎüâ ÏïåÎ¶º ÌÉ≠
                                    ui.card(
                                        ui.card_header("[D] Ïù¥ÏÉÅ Î∂àÎüâ ÏïåÎ¶º"),
                                        ui.output_ui("anomaly_alerts"),
                                        ui.output_ui("current_prediction2"),
                                    ),
                                    col_widths=[6, 6]
                                )    
                            ),
                            
                            # ================================
                            # TAB 2: Ïù¥ÏÉÅ ÏòàÏ∏°
                            # ================================
                            ui.nav_panel("Í≥µÏ†ï Ïù¥ÏÉÅ ÌÉêÏßÄ   (Process Anomaly Detection)",
                                ui.layout_columns(
                                    # TAB 2 [A] Ï£ºÏöî Î≥ÄÏàòÏùò Ïù¥ÏÉÅ Î∞úÏÉù ÌöüÏàò
                                    ui.card(
                                        ui.card_header("[A] Ï£ºÏöî Î≥ÄÏàòÏùò Ïù¥ÏÉÅ Î∞úÏÉù ÌöüÏàò"),
                                        ui.output_plot("anomaly_variable_count", height="300px")
                                    ),
                                    # TAB 2 [B] Ïù¥ÏÉÅ ÌÉêÏßÄ ÏïåÎ¶º
                                    ui.card(
                                        ui.card_header("[B] Ïù¥ÏÉÅ ÌÉêÏßÄ ÏïåÎ¶º"),
                                        ui.output_ui("log_alert_for_defect"),
                                        ui.input_action_button("clear_alerts", "‚úÖ ÏïåÎ¶º ÌôïÏù∏", class_="btn btn-sm btn-secondary")
                                    ),
                                    col_widths=[6, 6]
                                ),
                                ui.layout_columns(
                                    #TAB 2 [C] ÏãúÍ∞ÑÏóê Îî∞Î•∏ Ïù¥ÏÉÅ Î∂ÑÏÑù
                                    ui.card(
                                        ui.card_header("[C] ÏãúÍ∞ÑÏóê Îî∞Î•∏ Ïù¥ÏÉÅ Î∂ÑÏÑù"),
                                        ui.div(
                                            ui.input_select(
                                                "anomaly_chart_time_unit", 
                                                "ÏãúÍ∞Ñ Îã®ÏúÑ ÏÑ†ÌÉù", 
                                                choices=["1ÏãúÍ∞Ñ", "3ÏãúÍ∞Ñ", "Ïùº", "Ï£º", "Ïõî"], 
                                                selected="Ïùº"
                                            ),
                                            class_="mb-3"
                                        ),
                                        ui.output_plot("anomaly_p_chart", height="300px")
                                    ),
                # [D] SHAP Ìï¥ÏÑù, Î≥ÄÏàò Í∏∞Ïó¨ÎèÑ Î∂ÑÏÑù
                                    ui.card(
                                        ui.card_header("[D] Ïù¥ÏÉÅÏπò ÌÉêÏßÄ ÏïåÎ¶º ÏÉÅÏÑ∏"),
                                        ui.output_ui("anomaly_detail_table"),
                                        ui.input_action_button("clear_alerts2", "üîî ÏïåÎ¶º ÌôïÏù∏ (Ï¥àÍ∏∞Ìôî)", class_="btn btn-sm btn-outline-secondary mb-2")
                                    ),
                                    col_widths=[6, 6]
                                )
                            ),
                            # ================================
                            # TAB 3: ÌíàÏßà
                            # ================================
                    
                                ui.nav_panel("ÌíàÏßà Ïù¥ÏÉÅ ÌåêÎ≥Ñ   (Quality Defect Classification)",
                                    # TAB 3 [A] 
                                    ui.layout_columns(
                                        ui.card(
                                            ui.card_header("[A]"),
                                            ui.input_date_range(
                                                "date_range", 
                                                "üìÖ Í∏∞Í∞Ñ ÏÑ†ÌÉù", 
                                                start="2019-02-21",  # Îç∞Ïù¥ÌÑ∞ ÏãúÏûëÏùº
                                                end="2019-03-12",    # Îç∞Ïù¥ÌÑ∞ Ï¢ÖÎ£åÏùº # Í∏∞Î≥∏Í∞í
                                            ),
                                            ui.output_plot("defect_rate_plot", height="300px"),
                    
                                        ),
                                        # TAB 3 [B]
                                        ui.card(
                                            ui.card_header("[B]"),
                                            ui.output_ui("current_prediction"),
                                            ui.output_ui("prediction_log_table")
                                        )
                                    ),
                                    # TAB 3 [C]
                                    ui.layout_columns(
                                        ui.card(
                                            ui.card_header("[C]"),
                                            ui.input_select(
                                                "fail_time_unit", 
                                                "ÏãúÍ∞Ñ Îã®ÏúÑ ÏÑ†ÌÉù", 
                                                choices=["1ÏãúÍ∞Ñ", "3ÏãúÍ∞Ñ", "Ïùº", "Ï£º", "Ïõî"], 
                                                selected="Ïùº"
                                            ),
                                            ui.output_plot("fail_rate_by_time", height="350px")
                                        ),
                                        ui.card(
                                            ui.card_header("[D]"),
                                            
                                        )
                                    )
                                ),
                                ui.nav_spacer(),  # ÏÑ†ÌÉù
                            ui.nav_panel("üîì Î°úÍ∑∏ÏïÑÏõÉ",  # ‚úÖ Ïó¨Í∏∞ Ï∂îÍ∞Ä!
                                ui.layout_column_wrap(
                                    ui.h4("Î°úÍ∑∏ÏïÑÏõÉ ÌïòÏãúÍ≤†ÏäµÎãàÍπå?"),
                                    ui.input_action_button("logout_button", "Î°úÍ∑∏ÏïÑÏõÉ", class_="btn btn-danger")
                                )
                            ),
                                id="main_nav",
                                title = "LS Í∏∞Í∞Ä ÌéôÌÜ†Î¶¨"
                            )
                        )
            
            
# ================================
# üöÄ 4. Ïï± Ïã§Ìñâ
# ================================
app = App(app_ui, server, static_assets=STATIC_DIR)
